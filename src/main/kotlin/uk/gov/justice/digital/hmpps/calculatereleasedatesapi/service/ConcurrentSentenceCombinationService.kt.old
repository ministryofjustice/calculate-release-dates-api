package uk.gov.justice.digital.hmpps.calculatereleasedatesapi.service

import org.slf4j.Logger
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import uk.gov.justice.digital.hmpps.calculatereleasedatesapi.enumerations.SentenceIdentificationTrack
import uk.gov.justice.digital.hmpps.calculatereleasedatesapi.exceptions.CannotMergeSentencesException
import uk.gov.justice.digital.hmpps.calculatereleasedatesapi.model.Booking
import uk.gov.justice.digital.hmpps.calculatereleasedatesapi.model.Sentence

@Service
class ConcurrentSentenceCombinationService(
  val sentenceCombinationService: SentenceCombinationService
) {

  fun combineConcurrentSentences(booking: Booking): Booking {
    val workingBooking: Booking = booking.copy()
    // find a list of sentences that have consecutive sentences
    val concurrentSentences = booking.sentences.filter {
      it.identificationTrack == SentenceIdentificationTrack.SDS_BEFORE_CJA_LASPO
    }.filter {
      it.consecutiveSentences.isEmpty()
    }S

    if (
      concurrentSentences.isNotEmpty() &&
      concurrentSentences.size == booking.sentences.size
    ) {
      for (sentence in concurrentSentences) {
        combineSentencePair(sentence, workingBooking)
      }
    }
    return workingBooking
  }

  private fun combineSentencePair(
    sentence: Sentence,
    workingBooking: Booking
  ) {

    val concurrentSentences = workingBooking.sentences.filter {
      it.identificationTrack == SentenceIdentificationTrack.SDS_BEFORE_CJA_LASPO
    }.filter {
      workingBooking.sentences.contains(it)
    }.filter {
      it.isSentenceCalculated()
    }
    for (concurrentSentence in concurrentSentences) {
      if (
        sentence != concurrentSentence &&
        sentence.isSentenceCalculated()
      ) {
        sentenceCombinationService.combineTwoSentences(
          sentence,
          concurrentSentence,
          workingBooking,
          this::mergeConcurrentSentences
        )
      }
    }
  }

  fun mergeConcurrentSentences(firstSentence: Sentence, secondSentence: Sentence): Sentence {

    if (firstSentence.identificationTrack != secondSentence.identificationTrack) {
      throw CannotMergeSentencesException("Incompatible sentence types")
    }

    log.info("Merging:\n\n{}\n\nto\n\n{}", firstSentence, secondSentence)

    return Sentence(
      sentenceCombinationService.earliestOffence(firstSentence, secondSentence),
      sentenceCombinationService.adjustedDuration(firstSentence, secondSentence),
      sentenceCombinationService.earliestSentencedAt(firstSentence, secondSentence),
    )
  }

  companion object {
    val log: Logger = LoggerFactory.getLogger(this::class.java)
  }
}
